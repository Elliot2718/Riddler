{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4a4d5cad-c9b1-411a-a120-453fe51fd93e",
   "metadata": {},
   "source": [
    "# Riddler: Fibonacci at the Post Office\n",
    "https://fivethirtyeight.com/features/is-it-anyones-birthday/\n",
    "\n",
    "_A postal worker and his customer joke about the various ways the customer could mathematically encode her post office box number. The customer realizes that every integer greater than 1 can be encoded via at least one Fibonacci-like sequence using an ordered triple (m, n, q). The encoded number is the qth member of the sequence after the first two positive integers m and n, where each term is the sum of the previous two terms. For example, 7 has the encodings (3, 4, 1) and (1, 3, 2). In an attempt to stump the postal worker, the customer prefers encodings with a maximal value of q. What encoding should she use for the number 81? **Extra credit:** What encoding should she use for the number 179?_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 327,
   "id": "85dac630-16b6-4242-8602-1edd21cc8e4d",
   "metadata": {},
   "outputs": [],
   "source": [
    "from itertools import product\n",
    "from pprint import pprint"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d5e018c5-9fab-45d1-a2a5-97a62965f0e3",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "## Try different implementations of the Fibonacci sequence in Python\n",
    "I haven't implemented the Fibonacci sequence in Python before, so I first want to play around with different implementations of it. I found a tutorial here: https://realpython.com/fibonacci-sequence-python/"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a534242-9251-4b65-b7eb-6d5fbb4b03de",
   "metadata": {
    "tags": []
   },
   "source": [
    "### Using recursion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a8964aae-d121-4ad5-9d78-e1b5ba7110cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def fibonacci_recursive(n):\n",
    "    if n in (0, 1):\n",
    "        return n\n",
    "    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ddb598ed-c3f3-4847-be0d-099cb7048427",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "9227465"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fibonacci_recursive(35)\n",
    "\n",
    "# This is really slow after you get past n = 35 or so"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9be88e0b-7773-4463-89ae-cbffd0dd3bb3",
   "metadata": {},
   "source": [
    "### Using recursion plus caching"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "78f3063f-749c-4dd2-beb2-e5c0a299c413",
   "metadata": {},
   "outputs": [],
   "source": [
    "cache = {0: 0, 1: 1}\n",
    "def fibonacci_memoized(n):\n",
    "    if n in cache:\n",
    "        return cache[n]\n",
    "    cache[n] = fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)\n",
    "    return cache[n]\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "cb6057a7-df61-42ec-9456-b87f44582e9b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fibonacci_memoized(1000)\n",
    "\n",
    "# This is really fast even up to 1000!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4e2a95bd-319d-43e6-8037-767f4233ff04",
   "metadata": {},
   "source": [
    "### Using iteration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "a386c439-069c-4427-a4b1-be7ac29b1d09",
   "metadata": {},
   "outputs": [],
   "source": [
    "cache = {0: 0, 1: 1}\n",
    "\n",
    "def fibonacci_iterative(n):\n",
    "    if n in cache:\n",
    "        return cache[n]\n",
    "    else:\n",
    "        fib_number = fibonacci_iterative(n - 1) + fibonacci_iterative(n - 2)\n",
    "        cache[n] = fib_number\n",
    "    return cache[n]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "850b1a8b-c3b7-4179-8409-abc8b932eeb6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fibonacci_iterative(1000)\n",
    "\n",
    "# This is also fast!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1d04416f-23c5-4384-a78f-b0662d4eab71",
   "metadata": {},
   "source": [
    "### Using recursion and a class"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "5ab85bef-552e-432d-8701-0b59e4cd1e9d",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Fibonacci:\n",
    "    def __init__(self):\n",
    "        self.cache = [0, 1]\n",
    "        \n",
    "    def __call__(self, n):\n",
    "        if n < len(self.cache):\n",
    "            return self.cache[n]\n",
    "        else:\n",
    "            fib_number = self(n - 1) + self(n - 2)\n",
    "            self.cache.append(fib_number)\n",
    "            \n",
    "        return self.cache[n]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "b05234d2-47ba-409d-a2b7-b14b514de675",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fibonacci_number = Fibonacci()\n",
    "fibonacci_number(1000)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c305a66-e923-497f-b1c6-bbf24208fa72",
   "metadata": {
    "tags": []
   },
   "source": [
    "## Now to the problem..."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c5f0e6c-28d1-4358-9d7f-2453b4a705cd",
   "metadata": {
    "tags": []
   },
   "source": [
    "### Initial thoughts"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3b54ca1-4b3a-4d52-8b3e-e1c049c4ebb3",
   "metadata": {
    "tags": []
   },
   "source": [
    "The hard part of this problem will be determining how we know that we have the maximal value of q. It's clear that the minimal solution for a given number N is always 1. That is, the tuple (1, N-1, 1), i.e. the sequence 1, N-1, N, ..., always works. But given a solution, how do we know it is maximal? That is not immediately obvious to me, besides that n and m should be as small as possible.\n",
    "\n",
    "My first thought is to go with a brute force solution. That is, for a number N (e.g. 81) generate all possible sequences with m,n < N, find all sequences that contain the number N and find the sequence with maximal q. This honestly seems a bit boring. Surely there is a slicker solution. I spent some time working on this problem on paper, trying to find something, but I didn't figure anything out ðŸ˜¢.\n",
    "\n",
    "#### But wait!\n",
    "Ok, I did figure one thing out on paper that may make the brute force solution more efficient. After writing down some sequences, I noticed that a sequence defined by (m, n) can be written as the linear combination of two Fibonacci sequences.\n",
    "\n",
    "**Lemma**: Let $m, n$ be positive integers. Then each Fibonacci-like sequence $G_q$ defined recursively as $G_1=m, G_2=n$ and $G_q=G_q+G_{q+1}$ can be written as a linear combination the Fibonacci sequence $F_q$ as $G_q = mF_{q-3}+nF_{q-2}$.\n",
    "\n",
    "**Proof**: We can prove this inductively.\n",
    "\n",
    "_Base Case_: We have previously defined $G_3=m+n,F_1=1$ and $F_2=1$. Therefore, $mF_1+nF_2=m+n=G_3$.\n",
    "\n",
    "_Induction_: Suppose that $G_q = mF_{q-3}+nF_{q-2}$ and $G_{q-1}=mF_{q-4}+nF_{q-3}$. Then,\n",
    "\n",
    "\\begin{equation} \\label{eq1}\n",
    "\\begin{split}\n",
    "G_{q+1} & = G_q+G_{q-1} \\\\\n",
    "& = mF_{q-3}+nF_{q-2} + mF_{q-4}+nF_{q-3} \\\\\n",
    "& = m(F_{q-3}+F_{q-4}) + n(F_{q-2}+F_{q-3}) \\\\\n",
    "& = mF_{q-2}+nF_{q-1}\n",
    "\\end{split}\n",
    "\\end{equation}\n",
    "\n",
    "which completes the proof. $\\blacksquare$\n",
    "\n",
    "So what does that get us? This means that for a given number N, we only need to generate the Fibonacci sequence, and then we can generate all possible Fibonacci-like sequences by simple multiplication. Let's try it!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1619e8dc-58cf-4429-93be-3437ca02757d",
   "metadata": {},
   "source": [
    "### Working on a solution "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "4590d8a0-2796-431f-bdd8-5369d7ae021f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# First write a function for the Fibonacci sequence. I'll use the Fibonacci class from above.\n",
    "\n",
    "# First, just generate the sequence out likely farther than we need.\n",
    "fibonacci_number = Fibonacci()\n",
    "fibs = [fibonacci_number(n) for n in range(20)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "8fa2e843-e6e7-4c94-96b5-4957f01a1c35",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n"
     ]
    }
   ],
   "source": [
    "print(fibs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 367,
   "id": "2ada9a53-3e37-47a1-a2d4-61fb3860f92d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Now create all variations for positive integers m, n\n",
    "class Fibonacci:\n",
    "    def __init__(self):\n",
    "        self.cache = [0, 1]\n",
    "        \n",
    "    def __call__(self, n):\n",
    "        if n < len(self.cache):\n",
    "            return self.cache[n]\n",
    "        else:\n",
    "            fib_number = self(n - 1) + self(n - 2)\n",
    "            self.cache.append(fib_number)\n",
    "            \n",
    "        return self.cache[n]\n",
    "\n",
    "\n",
    "def post_office_sequence(m,n,length):\n",
    "    \"\"\"Returns a list of digits of the post office sequence, of the provided length\"\"\"\n",
    "    fibonacci_number = Fibonacci()\n",
    "    # Use max(m,n) as a reasonable max required length\n",
    "    fibs = [m*fibonacci_number(i)+n*fibonacci_number(i+1) for i in range(1,length-2)]\n",
    "    #initialize with the first three elements\n",
    "    like_fibs=[0,m,n]\n",
    "    like_fibs.extend(fibs)\n",
    "    return like_fibs\n",
    "\n",
    "\n",
    "def all_possible_inputs(max_coeff):\n",
    "    \"\"\"Returns a list of all possible (m,n) for m,n=1 through max(m,n)\"\"\"\n",
    "    return list(product(range(1,max_coeff+1),repeat=2))\n",
    "\n",
    "\n",
    "def all_sequences(max_coeff, length):\n",
    "    \"\"\"Returns a dictionary with input tuples as keys and post office sequences generated using those keys as values\"\"\"\n",
    "    return {i:post_office_sequence(i[0],i[1],length) for i in all_possible_inputs(max_coeff)}\n",
    "\n",
    "\n",
    "def maximal_q_encoding(q, length):\n",
    "    \"\"\"Find the encoding and sequence produced by the encoding for the sequence with maximal q\"\"\"\n",
    "    sequence_data = [(coeff, sequence, q in sequence, sequence.index(q) if q in sequence else None) for coeff, sequence in all_sequences(q,length).items()]\n",
    "\n",
    "    # Filter for sequences containing q and sort by index \n",
    "    filtered_sequence_data = list(filter(lambda s: s[2] == True, sequence_data))\n",
    "    sorted_sequence_data = sorted(filtered_sequence_data, key=lambda sequence: sequence[3], reverse=True)\n",
    "    return sorted_sequence_data[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d46f5000-5ffe-4cfa-8b57-8498d4732a6f",
   "metadata": {},
   "source": [
    "### The Answer!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 374,
   "id": "b3329f84-c6ec-4485-a4b6-7c01261c4366",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "((3, 2), [0, 3, 2, 5, 7, 12, 19, 31, 50, 81, 131, 212, 343, 555, 898], True, 9)\n",
      "((11, 7),\n",
      " [0, 11, 7, 18, 25, 43, 68, 111, 179, 290, 469, 759, 1228, 1987, 3215],\n",
      " True,\n",
      " 8)\n"
     ]
    }
   ],
   "source": [
    "pprint(maximal_q_encoding(81,15))\n",
    "# For q = 81, the maximal sequence is m = 3, n = 2 and 81 appears as the 9th digit of the sequence, or 6th digit if you are excluding 0, m and n as in the puzzle syntax.\n",
    "\n",
    "pprint(maximal_q_encoding(179,15))\n",
    "# For q = 81, the maximal sequence is m = 11, n = 7 and 81 appears as the 8th digit of the sequence, or 5th digit if you are excluding 0, m and n as in the puzzle syntax."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "env",
   "language": "python",
   "name": "env"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
